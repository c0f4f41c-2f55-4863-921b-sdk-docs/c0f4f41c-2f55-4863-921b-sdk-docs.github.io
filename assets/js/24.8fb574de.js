(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{414:function(t,e,a){"use strict";a.r(e);var r=a(11),o=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"initializing-dapps"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#initializing-dapps"}},[t._v("#")]),t._v(" Initializing Dapps")]),t._v(" "),a("p",[t._v("Once you have your basic dev environment "),a("a",{attrs:{href:"./Getting-Started"}},[t._v("set up")]),t._v(", you are ready to start interacting with some smart contracts. There are some basic things you'll need, regardless of what convenience library you're using, when communicating with a smart contract:")]),t._v(" "),a("h2",{attrs:{id:"the-contract-network"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#the-contract-network"}},[t._v("#")]),t._v(" The Contract Network")]),t._v(" "),a("p",[t._v("If you aren't connected to the right network, you aren't going to have any luck sending transactions to your contract, so make sure you have this right! Many dapp developers choose to deploy their contract to a testnet first, in order to avoid potentially disastrous fees if something goes wrong during development and testing on mainnet.")]),t._v(" "),a("p",[t._v("No matter which network you deploy your final dapp on, your user will need to be able to access it. MetaMask makes available "),a("a",{attrs:{href:"https://docs.metamask.io/guide/rpc-api.html#other-rpc-methods",target:"_blank",rel:"noopener noreferrer"}},[t._v("wallet_switchEthereumChain"),a("OutboundLink")],1),t._v(", as well as "),a("a",{attrs:{href:"https://docs.metamask.io/guide/rpc-api.html#wallet-addethereumchain",target:"_blank",rel:"noopener noreferrer"}},[t._v("wallet_addEthereumChain"),a("OutboundLink")],1),t._v(", which allows you to prompt the user to add a chain that you suggest, and switch to it using a confirmation dialogue.")]),t._v(" "),a("h2",{attrs:{id:"the-contract-address"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#the-contract-address"}},[t._v("#")]),t._v(" The Contract Address")]),t._v(" "),a("p",[t._v("Every account in Ethereum has an address, whether it's an external key-pair account, or a smart contract. In order for any smart contract library to communicate with your contracts, they'll need to know its exact address. If you deployed a contract, you probably know how to find the address, but if you're just getting started, check out our Knowledgebase "),a("a",{attrs:{href:"https://metamask.zendesk.com/hc/en-us/articles/360059683451-How-to-view-or-add-custom-token-contract-address",target:"_blank",rel:"noopener noreferrer"}},[t._v("explainer on finding contract addresses."),a("OutboundLink")],1)]),t._v(" "),a("h2",{attrs:{id:"the-contract-abi"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#the-contract-abi"}},[t._v("#")]),t._v(" The Contract ABI")]),t._v(" "),a("p",[t._v("In Ethereum, "),a("a",{attrs:{href:"https://solidity.readthedocs.io/en/develop/abi-spec.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("The ABI Specification"),a("OutboundLink")],1),t._v(" is a way to encode the interface of a smart contract in a way that is comprehensible to your user interface.\nIt is an array of method-describing objects, and when you feed this and the address into a contract-abstraction library, this "),a("code",[t._v("ABI")]),t._v(" tells those libraries about what methods to provide, and how to compose transactions to call those methods.")]),t._v(" "),a("p",[t._v("Example libraries include:")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://www.npmjs.com/package/ethers",target:"_blank",rel:"noopener noreferrer"}},[t._v("ethers"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://www.npmjs.com/package/web3",target:"_blank",rel:"noopener noreferrer"}},[t._v("web3.js"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://framework.embarklabs.io/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Embark"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://www.npmjs.com/package/ethjs",target:"_blank",rel:"noopener noreferrer"}},[t._v("ethjs"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://www.trufflesuite.com/",target:"_blank",rel:"noopener noreferrer"}},[t._v("truffle"),a("OutboundLink")],1)])]),t._v(" "),a("h2",{attrs:{id:"the-contract-bytecode"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#the-contract-bytecode"}},[t._v("#")]),t._v(" The Contract Bytecode")]),t._v(" "),a("p",[t._v("If your web app is going to publish a new smart contract that is pre-compiled, it may need to include some "),a("code",[t._v("bytecode")]),t._v(". In this case, you will not know the contract address in advance, but instead will have to publish, watch for the transaction to be processed, and then extract the final contract's address from the completed transaction.")]),t._v(" "),a("p",[t._v("If publishing a contract from bytecode, you will still want an "),a("code",[t._v("ABI")]),t._v(" if you want to interact with it! The bytecode does not describe how to interact with the final contract.")]),t._v(" "),a("h2",{attrs:{id:"the-contract-source-code"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#the-contract-source-code"}},[t._v("#")]),t._v(" The Contract Source Code")]),t._v(" "),a("p",[t._v("If your website is going to allow users to edit smart contract source code and compile it, like "),a("a",{attrs:{href:"http://remix.ethereum.org/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Remix"),a("OutboundLink")],1),t._v(", you may import a whole compiler. In this case you're going to derive your bytecode and ABI from that source code, and eventually you will derive the contract's address from the completed transaction, where that bytecode is published.")])])}),[],!1,null,null,null);e.default=o.exports}}]);